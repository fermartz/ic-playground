"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519KeyIdentity = exports.Ed25519PublicKey = void 0;
const agent_1 = require("@dfinity/agent");
const buffer_1 = require("buffer/");
const tweetnacl = __importStar(require("tweetnacl"));
class Ed25519PublicKey {
    // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
    constructor(key) {
        this.rawKey = key;
        this.derKey = Ed25519PublicKey.derEncode(key);
    }
    static from(key) {
        return this.fromDer(key.toDer());
    }
    static fromRaw(rawKey) {
        return new Ed25519PublicKey(rawKey);
    }
    static fromDer(derKey) {
        return new Ed25519PublicKey(this.derDecode(derKey));
    }
    static derEncode(publicKey) {
        if (publicKey.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {
            const bl = publicKey.byteLength;
            throw new TypeError(`ed25519 public key must be ${Ed25519PublicKey.RAW_KEY_LENGTH} bytes long (is ${bl})`);
        }
        // https://github.com/dfinity/agent-js/issues/42#issuecomment-716356288
        const derPublicKey = Uint8Array.from([
            ...Ed25519PublicKey.DER_PREFIX,
            ...new Uint8Array(publicKey),
        ]);
        return agent_1.derBlobFromBlob(agent_1.blobFromUint8Array(derPublicKey));
    }
    static derDecode(key) {
        const expectedLength = Ed25519PublicKey.DER_PREFIX.length + Ed25519PublicKey.RAW_KEY_LENGTH;
        if (key.byteLength !== expectedLength) {
            const bl = key.byteLength;
            throw new TypeError(`Ed25519 DER-encoded public key must be ${expectedLength} bytes long (is ${bl})`);
        }
        const rawKey = agent_1.blobFromUint8Array(key.subarray(Ed25519PublicKey.DER_PREFIX.length));
        if (!this.derEncode(rawKey).equals(key)) {
            throw new TypeError('Ed25519 DER-encoded public key is invalid. A valid Ed25519 DER-encoded public key ' +
                `must have the following prefix: ${Ed25519PublicKey.DER_PREFIX}`);
        }
        return rawKey;
    }
    toDer() {
        return this.derKey;
    }
    toRaw() {
        return this.rawKey;
    }
}
exports.Ed25519PublicKey = Ed25519PublicKey;
// The length of Ed25519 public keys is always 32 bytes.
Ed25519PublicKey.RAW_KEY_LENGTH = 32;
// Adding this prefix to a raw public key is sufficient to DER-encode it.
// See https://github.com/dfinity/agent-js/issues/42#issuecomment-716356288
Ed25519PublicKey.DER_PREFIX = Uint8Array.from([
    ...[48, 42],
    ...[48, 5],
    ...[6, 3],
    ...[43, 101, 112],
    ...[3],
    ...[Ed25519PublicKey.RAW_KEY_LENGTH + 1],
    ...[0], // 'no padding'
]);
class Ed25519KeyIdentity extends agent_1.SignIdentity {
    // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
    constructor(publicKey, _privateKey) {
        super();
        this._privateKey = _privateKey;
        this._publicKey = Ed25519PublicKey.from(publicKey);
    }
    static generate(seed) {
        if (seed && seed.length !== 32) {
            throw new Error('Ed25519 Seed needs to be 32 bytes long.');
        }
        const { publicKey, secretKey } = seed === undefined ? tweetnacl.sign.keyPair() : tweetnacl.sign.keyPair.fromSeed(seed);
        return new this(Ed25519PublicKey.fromRaw(agent_1.blobFromUint8Array(publicKey)), agent_1.blobFromUint8Array(secretKey));
    }
    static fromParsedJson(obj) {
        const [publicKeyDer, privateKeyRaw] = obj;
        return new Ed25519KeyIdentity(Ed25519PublicKey.fromDer(agent_1.blobFromHex(publicKeyDer)), agent_1.blobFromHex(privateKeyRaw));
    }
    static fromJSON(json) {
        const parsed = JSON.parse(json);
        if (Array.isArray(parsed)) {
            if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {
                return this.fromParsedJson([parsed[0], parsed[1]]);
            }
            else {
                throw new Error('Deserialization error: JSON must have at least 2 items.');
            }
        }
        else if (typeof parsed === 'object' && parsed !== null) {
            const { publicKey, _publicKey, secretKey, _privateKey } = parsed;
            const pk = publicKey
                ? Ed25519PublicKey.fromRaw(agent_1.blobFromUint8Array(new Uint8Array(publicKey.data)))
                : Ed25519PublicKey.fromDer(agent_1.blobFromUint8Array(new Uint8Array(_publicKey.data)));
            if (publicKey && secretKey && secretKey.data) {
                return new Ed25519KeyIdentity(pk, agent_1.blobFromUint8Array(new Uint8Array(secretKey.data)));
            }
            else if (_publicKey && _privateKey && _privateKey.data) {
                return new Ed25519KeyIdentity(pk, agent_1.blobFromUint8Array(new Uint8Array(_privateKey.data)));
            }
        }
        throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);
    }
    static fromKeyPair(publicKey, privateKey) {
        return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);
    }
    static fromSecretKey(secretKey) {
        const keyPair = tweetnacl.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
        const identity = Ed25519KeyIdentity.fromKeyPair(agent_1.blobFromUint8Array(keyPair.publicKey), agent_1.blobFromUint8Array(keyPair.secretKey));
        return identity;
    }
    /**
     * Serialize this key to JSON.
     */
    toJSON() {
        return [agent_1.blobToHex(this._publicKey.toDer()), agent_1.blobToHex(this._privateKey)];
    }
    /**
     * Return a copy of the key pair.
     */
    getKeyPair() {
        return {
            secretKey: agent_1.blobFromUint8Array(new Uint8Array(this._privateKey)),
            publicKey: this._publicKey,
        };
    }
    /**
     * Return the public key.
     */
    getPublicKey() {
        return this._publicKey;
    }
    /**
     * Signs a blob of data, with this identity's private key.
     * @param challenge - challenge to sign with this identity's secretKey, producing a signature
     */
    async sign(challenge) {
        const blob = challenge instanceof buffer_1.Buffer
            ? agent_1.blobFromBuffer(challenge)
            : agent_1.blobFromUint8Array(new Uint8Array(challenge));
        const signature = tweetnacl.sign.detached(blob, this._privateKey);
        return agent_1.blobFromUint8Array(signature);
    }
}
exports.Ed25519KeyIdentity = Ed25519KeyIdentity;
//# sourceMappingURL=ed25519.js.map